# run_pipeline.py (Versi√≥n Optimizada con Integraci√≥n IA)
import json
import os
import sys
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from pathlib import Path

# ‚úÖ NUEVAS IMPORTACIONES PARA INTEGRACI√ìN
try:
    from src.model_training.train_model import train_model
    from src.data_preparation.populate_chroma import populate_database
    ML_MODULES_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è M√≥dulos ML no disponibles: {e}")
    ML_MODULES_AVAILABLE = False

# ‚úÖ INTEGRACI√ìN CON ULTIMATE ANALYZER
try:
    from ultimate_trade_analyzer import UltimateTradeAnalyzer
    ULTIMATE_ANALYZER_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è Ultimate Analyzer no disponible - modo b√°sico")
    ULTIMATE_ANALYZER_AVAILABLE = False

class OptimizedPipeline:
    def __init__(self):
        self.config = None
        self.valid_combinations = []
        self.results = {
            'successful': 0,
            'failed': 0,
            'skipped': 0,
            'total_processing_time': 0,
            'combinations_processed': []
        }
        self.start_time = None
        
    def validate_prerequisites(self):
        """‚úÖ VALIDACI√ìN MEJORADA con verificaciones adicionales"""
        print("üîç Validando prerequisitos del pipeline optimizado...")
        
        issues = []
        warnings = []
        
        # 1. Archivo de configuraci√≥n principal
        config_path = 'configs/optimized_parameters.json'
        if not os.path.exists(config_path):
            issues.append("‚ùå Falta 'configs/optimized_parameters.json'")
            issues.append("   üëâ Ejecuta: python run_optimization.py -> python direct_config_generator.py")
        else:
            # Verificar estructura del archivo
            try:
                with open(config_path, 'r') as f:
                    config = json.load(f)
                
                # Contar estrategias v√°lidas
                strategy_count = 0
                for symbol, strategies in config.items():
                    if symbol == 'generation_info':
                        continue
                    if isinstance(strategies, dict):
                        strategy_count += len(strategies)
                
                if strategy_count == 0:
                    issues.append("‚ùå No se encontraron estrategias v√°lidas en el archivo de configuraci√≥n")
                else:
                    print(f"‚úÖ Configuraci√≥n v√°lida: {strategy_count} estrategias encontradas")
            except json.JSONDecodeError:
                issues.append("‚ùå Archivo de configuraci√≥n corrupto")
        
        # 2. M√≥dulos ML
        if not ML_MODULES_AVAILABLE:
            warnings.append("‚ö†Ô∏è M√≥dulos ML no disponibles - funcionalidad limitada")
        else:
            print("‚úÖ M√≥dulos ML disponibles")
        
        # 3. Ultimate Analyzer
        if not ULTIMATE_ANALYZER_AVAILABLE:
            warnings.append("‚ö†Ô∏è Ultimate Analyzer no disponible - an√°lisis b√°sico")
        else:
            print("‚úÖ Ultimate Analyzer disponible para an√°lisis avanzado")
        
        # 4. Directorios necesarios
        required_dirs = ['src', 'configs', 'data/features']
        for dir_path in required_dirs:
            if not os.path.exists(dir_path):
                issues.append(f"‚ùå Falta directorio: {dir_path}")
        
        # 5. Verificar datos de features
        features_dir = Path('data/features')
        if features_dir.exists():
            feature_files = list(features_dir.glob('*_features.parquet'))
            if len(feature_files) == 0:
                issues.append("‚ùå No se encontraron archivos de features")
                issues.append("   üëâ Ejecuta el generador de features primero")
            else:
                print(f"‚úÖ {len(feature_files)} archivos de features encontrados")
        
        # Mostrar warnings
        if warnings:
            print("\n‚ö†Ô∏è ADVERTENCIAS:")
            for warning in warnings:
                print(f"  {warning}")
        
        # Mostrar errores cr√≠ticos
        if issues:
            print("\nüö® PROBLEMAS CR√çTICOS:")
            for issue in issues:
                print(f"  {issue}")
            return False
        
        print("‚úÖ Todos los prerequisitos est√°n listos")
        return True
    
    def load_configuration(self):
        """‚úÖ CARGA DE CONFIGURACI√ìN OPTIMIZADA"""
        try:
            with open('configs/optimized_parameters.json', 'r') as f:
                self.config = json.load(f)
            
            # Filtrar y validar combinaciones
            for symbol, strategies in self.config.items():
                if symbol == 'generation_info':
                    continue
                
                if not isinstance(strategies, dict):
                    continue
                
                for strategy_name, data in strategies.items():
                    if not isinstance(data, dict) or 'params' not in data:
                        print(f"‚ö†Ô∏è Datos incompletos para {symbol}_{strategy_name}")
                        continue
                    
                    # ‚úÖ PRIORIZACI√ìN por score
                    score = data.get('optimizer_score', 0)
                    
                    self.valid_combinations.append({
                        'symbol': symbol,
                        'strategy': strategy_name,
                        'data': data,
                        'score': score,
                        'priority': 'HIGH' if score >= 2.0 else 'MEDIUM' if score >= 1.5 else 'LOW'
                    })
            
            # ‚úÖ ORDENAR por prioridad y score
            self.valid_combinations.sort(key=lambda x: (-x['score'], x['priority']))
            
            print(f"üìä Configuraci√≥n cargada: {len(self.valid_combinations)} combinaciones v√°lidas")
            
            # Mostrar distribuci√≥n por prioridad
            priority_counts = {'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            for combo in self.valid_combinations:
                priority_counts[combo['priority']] += 1
            
            print(f"   üî• Alta prioridad: {priority_counts['HIGH']}")
            print(f"   ‚ö° Media prioridad: {priority_counts['MEDIUM']}")
            print(f"   üìà Baja prioridad: {priority_counts['LOW']}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error cargando configuraci√≥n: {e}")
            return False
    
    def process_combination_optimized(self, combination):
        """‚úÖ PROCESAMIENTO OPTIMIZADO DE COMBINACI√ìN INDIVIDUAL"""
        symbol = combination['symbol']
        strategy = combination['strategy']
        data = combination['data']
        score = combination['score']
        priority = combination['priority']
        
        start_time = time.time()
        
        print(f"\nüîß [{priority}] Procesando: {symbol}_{strategy} (Score: {score:.3f})")
        
        results = {
            'symbol': symbol,
            'strategy': strategy,
            'score': score,
            'priority': priority,
            'tasks_completed': [],
            'tasks_failed': [],
            'processing_time': 0,
            'status': 'PROCESSING'
        }
        
        # ‚úÖ TAREA 1: Entrenamiento ML (si est√° disponible)
        if ML_MODULES_AVAILABLE:
            try:
                print(f"    ü§ñ Entrenando modelo ML...")
                train_model(symbol, strategy)
                results['tasks_completed'].append('ML_TRAINING')
                print(f"    ‚úÖ Modelo ML entrenado")
            except Exception as e:
                print(f"    ‚ùå Error en ML training: {e}")
                results['tasks_failed'].append(f'ML_TRAINING: {str(e)}')
        
        # ‚úÖ TAREA 2: Poblaci√≥n de ChromaDB (si est√° disponible)
        if ML_MODULES_AVAILABLE:
            try:
                print(f"    üóÑÔ∏è Poblando ChromaDB...")
                populate_database(symbol, strategy)
                results['tasks_completed'].append('CHROMA_DB')
                print(f"    ‚úÖ ChromaDB poblado")
            except Exception as e:
                print(f"    ‚ùå Error en ChromaDB: {e}")
                results['tasks_failed'].append(f'CHROMA_DB: {str(e)}')
        
        # ‚úÖ TAREA 3: Validaci√≥n con Ultimate Analyzer (si est√° disponible)
        if ULTIMATE_ANALYZER_AVAILABLE and len(results['tasks_completed']) > 0:
            try:
                print(f"    üß† Ejecutando an√°lisis avanzado...")
                analyzer = UltimateTradeAnalyzer()
                
                # Ejecutar an√°lisis espec√≠fico para esta combinaci√≥n
                backtest_results = analyzer.run_backtest_with_details(symbol, strategy)
                if backtest_results:
                    analysis = analyzer.analyze_trade_patterns(backtest_results)
                    if analysis and analysis.get('total_trades', 0) > 0:
                        results['tasks_completed'].append('ULTIMATE_ANALYSIS')
                        results['analysis_summary'] = {
                            'total_trades': analysis['total_trades'],
                            'win_rate': analysis['win_rate'],
                            'profit_factor': analysis['profit_factor']
                        }
                        print(f"    ‚úÖ An√°lisis completado: {analysis['total_trades']} trades, {analysis['win_rate']:.1f}% WR")
                    else:
                        results['tasks_failed'].append('ULTIMATE_ANALYSIS: No trades generated')
                else:
                    results['tasks_failed'].append('ULTIMATE_ANALYSIS: Backtest failed')
            except Exception as e:
                print(f"    ‚ùå Error en Ultimate Analysis: {e}")
                results['tasks_failed'].append(f'ULTIMATE_ANALYSIS: {str(e)}')
        
        # Calcular resultado final
        processing_time = time.time() - start_time
        results['processing_time'] = processing_time
        
        total_tasks = len(results['tasks_completed']) + len(results['tasks_failed'])
        success_rate = len(results['tasks_completed']) / max(total_tasks, 1) * 100
        
        if len(results['tasks_completed']) == 0:
            results['status'] = 'FAILED'
            status_icon = "‚ùå"
        elif len(results['tasks_failed']) == 0:
            results['status'] = 'SUCCESS'
            status_icon = "‚úÖ"
        else:
            results['status'] = 'PARTIAL'
            status_icon = "‚ö†Ô∏è"
        
        print(f"    {status_icon} Completado en {processing_time:.1f}s - √âxito: {success_rate:.0f}%")
        return results
    
    def run_parallel_processing(self, max_workers=3):
        """‚úÖ PROCESAMIENTO PARALELO OPTIMIZADO"""
        if not self.valid_combinations:
            print("‚ùå No hay combinaciones para procesar")
            return False
        
        print(f"\nüöÄ Iniciando procesamiento paralelo con {max_workers} workers")
        print(f"üìä Total combinaciones: {len(self.valid_combinations)}")
        
        self.start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Enviar tareas
            future_to_combination = {
                executor.submit(self.process_combination_optimized, combo): combo
                for combo in self.valid_combinations
            }
            
            # Procesar resultados
            for future in as_completed(future_to_combination):
                combination = future_to_combination[future]
                
                try:
                    result = future.result(timeout=300)  # 5 minutos timeout
                    
                    self.results['combinations_processed'].append(result)
                    
                    if result['status'] == 'SUCCESS':
                        self.results['successful'] += 1
                    elif result['status'] == 'FAILED':
                        self.results['failed'] += 1
                    else:
                        self.results['skipped'] += 1
                    
                    # Mostrar progreso
                    completed = len(self.results['combinations_processed'])
                    total = len(self.valid_combinations)
                    progress = completed / total * 100
                    
                    print(f"üìä Progreso: {completed}/{total} ({progress:.1f}%) - {result['status']}")
                    
                except Exception as e:
                    print(f"‚ùå Error procesando {combination['symbol']}_{combination['strategy']}: {e}")
                    self.results['failed'] += 1
        
        self.results['total_processing_time'] = time.time() - self.start_time
        return True
    
    def generate_comprehensive_report(self):
        """‚úÖ REPORTE COMPREHENSIVO"""
        print(f"\n" + "=" * 70)
        print("üìä REPORTE FINAL DEL PIPELINE OPTIMIZADO")
        print("=" * 70)
        
        # Estad√≠sticas generales
        total = len(self.results['combinations_processed'])
        successful = self.results['successful']
        failed = self.results['failed']
        partial = self.results['skipped']
        
        print(f"‚è±Ô∏è Tiempo total: {self.results['total_processing_time']:.1f} segundos")
        print(f"‚úÖ Exitosos: {successful}")
        print(f"‚ö†Ô∏è Parciales: {partial}")
        print(f"‚ùå Fallidos: {failed}")
        print(f"üìà Tasa de √©xito: {successful/max(total,1)*100:.1f}%")
        
        # An√°lisis por prioridad
        priority_stats = {'HIGH': {'success': 0, 'total': 0}, 'MEDIUM': {'success': 0, 'total': 0}, 'LOW': {'success': 0, 'total': 0}}
        
        for result in self.results['combinations_processed']:
            priority = result['priority']
            priority_stats[priority]['total'] += 1
            if result['status'] == 'SUCCESS':
                priority_stats[priority]['success'] += 1
        
        print(f"\nüìä AN√ÅLISIS POR PRIORIDAD:")
        for priority, stats in priority_stats.items():
            if stats['total'] > 0:
                success_rate = stats['success'] / stats['total'] * 100
                print(f"   {priority}: {stats['success']}/{stats['total']} ({success_rate:.1f}%)")
        
        # Top performers
        successful_combinations = [r for r in self.results['combinations_processed'] if r['status'] == 'SUCCESS']
        if successful_combinations:
            print(f"\nüèÜ TOP PERFORMERS:")
            sorted_successful = sorted(successful_combinations, key=lambda x: x['score'], reverse=True)
            
            for i, result in enumerate(sorted_successful[:5], 1):
                symbol = result['symbol']
                strategy = result['strategy']
                score = result['score']
                tasks = len(result['tasks_completed'])
                
                analysis_info = ""
                if 'analysis_summary' in result:
                    summary = result['analysis_summary']
                    analysis_info = f" | {summary['total_trades']} trades, {summary['win_rate']:.1f}% WR"
                
                print(f"   {i}. {symbol}_{strategy}: Score {score:.3f} | {tasks} tareas{analysis_info}")
        
        # Tareas m√°s problem√°ticas
        all_failed_tasks = []
        for result in self.results['combinations_processed']:
            all_failed_tasks.extend(result['tasks_failed'])
        
        if all_failed_tasks:
            from collections import Counter
            task_failures = Counter([task.split(':')[0] for task in all_failed_tasks])
            
            print(f"\n‚ùå TAREAS M√ÅS PROBLEM√ÅTICAS:")
            for task, count in task_failures.most_common(3):
                print(f"   {task}: {count} fallos")
        
        # Guardar reporte detallado
        report_data = {
            'timestamp': datetime.now().isoformat(),
            'pipeline_version': 'optimized_v1.0',
            'summary': {
                'total_combinations': total,
                'successful': successful,
                'partial': partial,
                'failed': failed,
                'success_rate': successful/max(total,1)*100,
                'total_processing_time': self.results['total_processing_time']
            },
            'priority_breakdown': priority_stats,
            'detailed_results': self.results['combinations_processed']
        }
        
        os.makedirs('reports', exist_ok=True)
        report_path = f"reports/pipeline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        print(f"\nüíæ Reporte detallado guardado: {report_path}")
        
        # Recomendaciones
        print(f"\nüí° RECOMENDACIONES:")
        if successful >= total * 0.8:
            print("   üéâ Excelente! La mayor√≠a de combinaciones fueron exitosas")
        elif successful >= total * 0.5:
            print("   üëç Buen rendimiento, considera revisar las fallas")
        else:
            print("   ‚ö†Ô∏è Muchas fallas detectadas, revisa la configuraci√≥n")
        
        if priority_stats['HIGH']['total'] > 0:
            high_success_rate = priority_stats['HIGH']['success'] / priority_stats['HIGH']['total']
            if high_success_rate < 0.8:
                print("   üî• Prioriza arreglar las estrategias de ALTA prioridad")
        
        return report_path

def main():
    """‚úÖ FUNCI√ìN PRINCIPAL OPTIMIZADA"""
    print("üöÄ PIPELINE OPTIMIZADO DE CONSTRUCCI√ìN ML")
    print("Incluye: Entrenamiento ML + ChromaDB + An√°lisis IA")
    print("=" * 60)
    
    pipeline = OptimizedPipeline()
    
    # Validaci√≥n
    if not pipeline.validate_prerequisites():
        print("\nüö® Corrige los problemas antes de continuar.")
        sys.exit(1)
    
    # Cargar configuraci√≥n
    if not pipeline.load_configuration():
        print("\n‚ùå Error cargando configuraci√≥n.")
        sys.exit(1)
    
    # Mostrar plan de ejecuci√≥n
    print(f"\nüìã PLAN DE EJECUCI√ìN:")
    print(f"   üîß Combinaciones a procesar: {len(pipeline.valid_combinations)}")
    print(f"   ü§ñ ML Training: {'‚úÖ' if ML_MODULES_AVAILABLE else '‚ùå'}")
    print(f"   üóÑÔ∏è ChromaDB: {'‚úÖ' if ML_MODULES_AVAILABLE else '‚ùå'}")
    print(f"   üß† Ultimate Analysis: {'‚úÖ' if ULTIMATE_ANALYZER_AVAILABLE else '‚ùå'}")
    
    # Confirmar ejecuci√≥n
    if len(pipeline.valid_combinations) > 10:
        response = input(f"\n‚ö†Ô∏è Se procesar√°n {len(pipeline.valid_combinations)} combinaciones. ¬øContinuar? (y/N): ")
        if response.lower() != 'y':
            print("‚ùå Operaci√≥n cancelada")
            sys.exit(0)
    
    # Ejecutar pipeline
    print(f"\nüöÄ Iniciando pipeline optimizado...")
    
    success = pipeline.run_parallel_processing(max_workers=3)
    
    if success:
        report_path = pipeline.generate_comprehensive_report()
        
        if pipeline.results['successful'] > 0:
            print(f"\nüéâ Pipeline completado exitosamente!")
            print(f"üìä {pipeline.results['successful']} combinaciones procesadas correctamente")
            print(f"üìÅ Reporte: {report_path}")
        else:
            print(f"\n‚ùå Pipeline fall√≥ - ninguna combinaci√≥n exitosa")
            sys.exit(1)
    else:
        print(f"\n‚ùå Error ejecutando pipeline")
        sys.exit(1)

if __name__ == '__main__':
    main()